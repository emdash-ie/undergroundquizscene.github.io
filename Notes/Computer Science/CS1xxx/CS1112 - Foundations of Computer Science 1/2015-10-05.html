<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>2015-10-05</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      div.line-block{white-space: pre-line;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="/Users/Noel/Developer/Projects/Notes/Build/note-style.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>In-class test next tuesday. Won’t include this week’s lectures, just everything up to last Tuesday. These are on the website now.</p>
<p>Working on next week’s lab will give us some good practice for the test. If we have that done ahead of time, then we can use the lab time next week for questions etc.</p>
<p>Next Monday’s lecture will be a revision lecture for the test.</p>
<section id="relations-on-single-sets" class="level1">
<h1>Relations on Single Sets</h1>
<p>Relations where the source and target sets are the same are called <em>homogeneous</em>.</p>
<p>We can sketch this in a new style, where we put the elements of the set in a circle and draw arrows between them.</p>
<section id="identity" class="level2">
<h2>Identity</h2>
<p>The identity relation I on any set A is the relation where every element is related to itself and only to itself.</p>
</section>
<section id="reflexive" class="level2">
<h2>Reflexive</h2>
<p>A homogeneous relation R subset AxA is <em>reflexive</em> only if every element of A is related to itself.<br />
E.g. &lt;= is reflexive because x &lt;= x for all x.</p>
<p>R is <em>anti-reflexive</em> only if no element of A is related to itself.<br />
E.g. &lt; is anti-reflexive because x &lt; x is not true for any number x.</p>
</section>
<section id="symmetric" class="level2">
<h2>Symmetric</h2>
<p>A homogeneous relation is <em>symmetric</em> only if whenever a is related to b, then b is also related to a.<br />
E.g. “is married to” is a symmetric relation.</p>
</section>
<section id="transitivity" class="level2">
<h2>Transitivity</h2>
<p>A homogeneous relation is <em>transitive</em> only if whenever a is related to b, and b is related to c in R, then a is also related to c.</p>
<p>(aRb and bRc implies aRc)</p>
</section>
<section id="equivalence-relation" class="level2">
<h2>Equivalence Relation</h2>
<p>A homoegeneous relation is an <em>equivalence relation</em> only if R is:</p>
<ul>
<li><p>reflexive</p></li>
<li><p>symmetric</p></li>
<li><p>transitive</p></li>
</ul>
<p>This concept comes from the relation “=” on numbers. Equality of sets fulfills these criteria.</p>
</section>
<section id="equivalence-class" class="level2">
<h2>Equivalence Class</h2>
<p>Given an equivalence relation R, we can use R to create a partition of A.</p>
<p>If aRb then a and b are both in the same partition subset.</p>
<p>If aRb is not true, then a and b are in different partition subsets.</p>
<p>These partitions are referred to <em>equivalence classes</em>.</p>
</section>
<section id="reflexive-closure" class="level2">
<h2>Reflexive Closure</h2>
<p>Sometimes we will want to start with a simple relation, to save space, and then describe how to make it larger.</p>
<p>The <em>reflexive closure</em> includes all reflexive pairs in the relation:</p>
<p>R = {(1,2), (2,4)}</p>
<p>reflexive closure = {(1,1), (1,2), (2,2), (3,3), (2,4), (4,4)}</p>
<p>So you add all the elements (of the relation = pairs here) needed to make the relation reflexive.</p>
</section>
<section id="symmetric-closure" class="level2">
<h2>Symmetric Closure</h2>
<p>The relation with all the elements needed to make it symmetric added.</p>
</section>
<section id="transitive-closure" class="level2">
<h2>Transitive Closure</h2>
<p>The relation with all the elements needed to make it transitive added.</p>
<p>Execute R after R (after R after…) repeatedly until you have all the elements, and add them to the transitive closure.</p>
<p>Example:</p>
<p>A = {1,2,3,4}</p>
<p>R = {(1,2), (2,4)}</p>
<p>R after R = R<sup>(2)</sup> = {(1,4)}</p>
<p>R after R after R = R<sup>(3)</sup> = {}</p>
<p>You go till n-1 where n is cardinality of A. In this case n is 4, so you go to R<sup>(3)</sup>. The transitive closure is the union of all of these sets.</p>
<p>Transitive closure of R = R ∪ R<sup>(2)</sup> ∪ R<sup>(3)</sup>.</p>
</section>
</section>
</body>
</html>
