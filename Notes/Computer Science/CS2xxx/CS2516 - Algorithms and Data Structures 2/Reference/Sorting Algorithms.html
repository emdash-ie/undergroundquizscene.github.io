<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Sorting Algorithms</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      div.line-block{white-space: pre-line;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="/Users/Noel/Developer/Projects/Github Page/Notes/note-style.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<section id="bubblesort" class="level1">
<h1>BubbleSort</h1>
<ul>
<li><p>Loop over the list, swapping adjacent elements if they’re out of order</p></li>
<li><p>Puts the next-biggest element in the next-last slot each time</p></li>
</ul>
<section id="time-complexity" class="level2">
<h2>Time Complexity</h2>
<ul>
<li>O(n^2) for best and worst case because it always does (n + n-1 + … + 1) comparisons</li>
</ul>
</section>
<section id="space-complexity" class="level2">
<h2>Space Complexity</h2>
<ul>
<li>Can be done in-place so O(1)</li>
</ul>
</section>
<section id="stability" class="level2">
<h2>Stability</h2>
<ul>
<li>Stable once swap condition is left &gt; right – elements with the same value will never be swapped past each other</li>
</ul>
</section>
</section>
<section id="selectionsort" class="level1">
<h1>SelectionSort</h1>
<ul>
<li><p>Find the next-smallest item each time and swap it into the next place from the start</p>
<ul>
<li>growing sorted list from the front</li>
</ul></li>
</ul>
<p>## Time Complexity</p>
<ul>
<li><p>Worst case and best case the same - O(n^2)</p>
<ul>
<li><p>have to search the whole unsorted section to find the next smallest item every time</p></li>
<li><p>n + n-1 + … + 1 = O(n^2)</p></li>
</ul></li>
</ul>
<section id="space-complexity-1" class="level2">
<h2>Space Complexity</h2>
<ul>
<li><p>Can be done in-place so O(1)</p></li>
<li><p>Otherwise O(n) for the PQ</p></li>
</ul>
</section>
<section id="stability-1" class="level2">
<h2>Stability</h2>
<ul>
<li><p>Not stable</p>
<ul>
<li><p>take the list [2, 3, 7, 4, 5, 2, 1]</p></li>
<li><p>first step will search the whole list for the 1, and then swap it with the first 2</p></li>
<li><p>first two is now after the second one: [1, 3, 7, 4, 5, 2, 2]</p></li>
</ul></li>
</ul>
</section>
</section>
<section id="insertionsort" class="level1">
<h1>InsertionSort</h1>
<ul>
<li><p>Grow sorted list from the front</p></li>
<li><p>Each time put the next item into the correct position in the sorted list</p></li>
</ul>
<p>## Time Complexity</p>
<ul>
<li><p>Worst case - O(n^2)</p>
<ul>
<li><p>list is already sorted backwards</p></li>
<li><p>have to shuffle each element the whole way to the front of the sorted section</p></li>
<li><p>1 + 2 + … + n-1 comparisons = O(n^2)</p></li>
</ul></li>
<li><p>Best case - O(n)</p>
<ul>
<li><p>list is already sorted</p></li>
<li><p>compare each element to the one before it - O(n)</p></li>
</ul></li>
</ul>
<section id="space-complexity-2" class="level2">
<h2>Space Complexity</h2>
<ul>
<li><p>Can be done in-place so O(1)</p></li>
<li><p>Otherwise O(n) for the PQ</p></li>
</ul>
</section>
<section id="stability-2" class="level2">
<h2>Stability</h2>
<ul>
<li><p>stable</p>
<ul>
<li><p>as long as you stop once you reach the same value when inserting</p></li>
<li><p>e.g. if you’re inserting a 4 and the sorted section already contains 4s, the new 4 must go to the right of the existing 4s</p></li>
</ul></li>
</ul>
</section>
</section>
<section id="heapsort" class="level1">
<h1>HeapSort</h1>
<ul>
<li><p>Put everything into a heap, then take it out again</p></li>
<li><p>Can be done in-place by growing a max heap from the front of the array and then taking the elements out one by one and putting them in the next-last place</p></li>
</ul>
<section id="time-complexity-on-log-n" class="level2">
<h2>Time Complexity – O(n log n)</h2>
<ul>
<li><p>O(log n) for each element added to heap</p>
<ul>
<li>so O(n log n)</li>
</ul></li>
<li><p>O(log n) for each element removed from the heap</p>
<ul>
<li>O(n log n)</li>
</ul></li>
<li><p>Best case: list already in max heap order – still O(n log n)</p>
<ul>
<li><p>O(n) to grow</p></li>
<li><p>still O(n log n) to shrink</p></li>
<li><p>total O(n log n)</p></li>
</ul></li>
</ul>
</section>
<section id="space-complexity-3" class="level2">
<h2>Space Complexity</h2>
<ul>
<li><p>O(n) for tree implementation – node for each element</p></li>
<li><p>O(1) for array-based implementation because it can be done in-place</p></li>
</ul>
</section>
<section id="stability-3" class="level2">
<h2>Stability</h2>
<ul>
<li><p>Not stable because of the heap</p>
<ul>
<li>though possibly stable if the list is already sorted in descending order?</li>
</ul></li>
</ul>
</section>
</section>
<section id="mergesort" class="level1">
<h1>MergeSort</h1>
<ul>
<li><p>Split the list in two and recursively sort the sections, then merge them</p>
<ul>
<li><p>to merge: repeatedly take the smaller of the next items in each section</p></li>
<li><p>base case: section with 0 or 1 elements is already sorted</p></li>
</ul></li>
<li><p>Difficult to do in-place, but can be done back-and-forth between two lists</p></li>
</ul>
<section id="time-complexity-on-log-n-1" class="level2">
<h2>Time Complexity – O(n log n)</h2>
<ul>
<li><p>Each merge is O(k) where k is the combined size of the sections</p>
<ul>
<li>each level of the call stack is O(n) – e.g. two sections, each O(n/2)</li>
</ul></li>
<li><p>Depth of call tree is O(log n)</p></li>
<li><p>So total is O(n log n)</p></li>
<li><p>Best case is still O(n log n) because the same amount of merging and number of comparisons are done</p></li>
</ul>
</section>
<section id="space-complexity-4" class="level2">
<h2>Space Complexity</h2>
<ul>
<li><p>O(n) for bottom-up with two lists</p></li>
<li><p>O(n log n) for implementations that create extra smaller lists</p></li>
</ul>
</section>
<section id="stability-4" class="level2">
<h2>Stability</h2>
<ul>
<li><p>Stable as long as the left-hand element is taken first when merging and two elements are equal</p>
<ul>
<li>e.g. if you’re merging two lists and the front element is 3 in each of them, take the left one first</li>
</ul></li>
</ul>
<p># QuickSort</p>
<ul>
<li><p>Choose a pivot</p>
<ul>
<li><p>move all elements less than the pivot before it and the rest after it</p></li>
<li><p>put the pivot in between</p></li>
<li><p>sort the subsections either side of the pivot recursively</p></li>
</ul></li>
<li><p>Efficient implementation avoids shuffling elements through the list by swapping out of place ones</p>
<ul>
<li>find one before the pivot that should be after, swap it with one that’s after the pivot but should be before</li>
</ul></li>
<li><p>QuickSort is fastest if each pivot is the median value – there’s an algorithm called median of medians which can guarantee this</p></li>
<li><p>Slowest if each pivot is the next smallest or largest value – can choose a random pivot or shuffle the list at the start to avoid this</p></li>
</ul>
</section>
</section>
<section id="time-complexity-on2-but-on-log-n-on-average" class="level1">
<h1>Time Complexity – O(n^2) but O(n log n) on average</h1>
<ul>
<li><p>Worst case – O(n^2)</p>
<ul>
<li><p>if each pivot is the next smallest or next largest value</p></li>
<li><p>so the tree gets to maximum depth (n)</p></li>
</ul></li>
<li><p>Best case – better than O(n log n)?</p>
<ul>
<li><p>each pivot is the median</p></li>
<li><p>tree depth is O(log n)</p></li>
<li><p>but it’s less than n comparisons at each level, because the pivots from the last level aren’t included, and there’s only one comparison for each element that isn’t the pivot in a given sublist</p></li>
</ul></li>
<li><p>Average – O(n log n)</p></li>
</ul>
<section id="space-complexity-5" class="level2">
<h2>Space Complexity</h2>
<ul>
<li><p>Can be done in-place, so O(1)</p></li>
<li><p>If a new list is created, then O(n log n), possibly better</p></li>
</ul>
</section>
<section id="stability-5" class="level2">
<h2>Stability</h2>
<ul>
<li><p>not stable with the random shuffle</p></li>
<li><p>without it it might be</p></li>
</ul>
</section>
</section>
<section id="bucketsort" class="level1">
<h1>BucketSort</h1>
<ul>
<li><p>Make a bucket for each possible value, pass through the list, putting each item into the right bucket</p></li>
<li><p>Then empty the buckets in order</p></li>
<li><p>Not a comparison sort</p></li>
</ul>
<section id="time-complexity-on-n" class="level2">
<h2>Time Complexity – O(n + N)</h2>
<ul>
<li><p>N is the number of buckets, n is the length of the list</p></li>
<li><p>Create buckets is O(N)</p></li>
<li><p>Pass through the list to put in buckets is O(n)</p></li>
<li><p>Processing buckets is O(N)</p></li>
<li><p>O(n) assignments to create the list again</p></li>
<li><p>Total of O(n + N)</p></li>
</ul>
</section>
<section id="space-complexity-on-n-or-on" class="level2">
<h2>Space Complexity – O(n + N) or O(N)</h2>
<ul>
<li><p>N buckets, n elements added across them</p></li>
<li><p>though you could say that things can be moved to buckets rather than copied to them, in which case it’s just O(N) space</p></li>
</ul>
</section>
<section id="stability-6" class="level2">
<h2>Stability</h2>
<ul>
<li>Stable if buckets are FIFO</li>
</ul>
</section>
</section>
<section id="radixsort" class="level1">
<h1>RadixSort</h1>
<ul>
<li><p>One bucket sort for each character (or digit), starting from the right</p></li>
<li><p>Works because bucket sort is stable</p></li>
</ul>
<section id="time-complexity-omn" class="level2">
<h2>Time Complexity – O(mn)</h2>
<ul>
<li><p>O(n + 10) for each digit (because there are 10 possible digits {0, 1, 2, …, 9} and so 10 buckets), which is ~= O(n) for n &gt; 10</p></li>
<li><p>So O(mn) total, where m is the maximum number of digits in the input list (e.g. if the largest number in a list of integers is 10749, m = 5)</p></li>
<li><p>According to Ken’s notes time complexity for radixsort is unclear, though, so I’ve probably oversimplified here</p></li>
</ul>
</section>
<section id="space-complexity-on-or-o1" class="level2">
<h2>Space Complexity – O(n) or O(1)</h2>
<ul>
<li><p>O(1) for buckets</p>
<ul>
<li><p>this is for base 10 numbers</p></li>
<li><p>for characters, it’s constant but may be quite large if you need to support a lot of possibly characters (e.g. utf)</p></li>
</ul></li>
<li><p>O(n) for filling buckets</p></li>
<li><p>Total of O(n)</p></li>
<li><p>or possibly O(1) if you move rather than copy, as mentioned in bucketsort</p></li>
</ul>
</section>
<section id="stability-7" class="level2">
<h2>Stability</h2>
<ul>
<li>stable because requires stable bucketsort</li>
</ul>
</section>
</section>
</body>
</html>
