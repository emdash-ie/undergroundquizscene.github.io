<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Logic Design Sample Solution Summer 2014</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      div.line-block{white-space: pre-line;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="/Users/Noel/Developer/Projects/Github Page/Notes/note-style.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<section id="sample-solution-for-summer-2014" class="level1">
<h1>Sample Solution for Summer 2014</h1>
<hr />
<section id="question-1" class="level2">
<h2>Question 1</h2>
<section id="a" class="level3">
<h3>(a)</h3>
<pre><code>f = (A + B + C) . (A + B + C&#39;) . (A + B&#39; + C&#39;) . (A&#39; + B + C) . (A&#39; + B + C&#39;)</code></pre>
</section>
<section id="b" class="level3">
<h3>(b)</h3>
<p>Each term in the CSOP form corresponds to a row in the truth table for g in which the output is 1. Similarly, each term in the CPOS form corresponds to a row with output 0. If there are fewer terms in the CPOS form, then there are more 1s than 0s in the truth table for g.</p>
</section>
<section id="c" class="level3">
<h3>(c)</h3>
<p>Minterms contain each input variable only once, either inverted or not inverted. Simplified products, as they come from simplified representations of the CSOP form, do not contain all input variables – some are missing because they have been factored out as redundant terms.</p>
</section>
</section>
<section id="question-2" class="level2">
<h2>Question 2</h2>
<section id="a-1" class="level3">
<h3>(a)</h3>
<p>These functions can have any number of arguments. However, a majority decoder with 1 argument is equivalent to the identity function. Additionally, majority decoders with even numbers of arguments have cases where neither 1 nor 0 is in the majority among argument values. So behaviour is undefined for some argument value combinations.</p>
</section>
<section id="b-1" class="level3">
<h3>(b)</h3>
<p>Neither form should be preferred, as they will always be the same length.</p>
<p>Majority decoders with an odd number of arguments will output 0 in half of the cases and 1 in the other half of the cases. With an even number of arguments, where n is the number of arguments, <code>m = ((2^n) - 1)/3</code> cases will have majority 0s, the same number will have majority 1s, and <code>m + 1</code> cases will have an even number of 1s and 0s.</p>
</section>
<section id="c-1" class="level3">
<h3>(c)</h3>
<p>Yes, the simplified forms will always have a shorter representation, as long as the number of arguments is greater than 2.</p>
<p>Take the Karnaugh map for a majority decoder with more than 2 arguments. The case where all arguments have the value 1 will have (at least) one neighbour where the arguments are all 1 except for one of them, as all neighbours in a Karnaugh map will have 1 more or 1 fewer 1s among their arguments than each other.</p>
<p>So there’ll be one group of 2 that can be made. Even if all other 1s have to be covered singly, there’ll be 1 fewer term in the result than in the canonical representation. A similar argument can be made for the SPOS form.</p>
<p>Then, for 2 arguments, the simplified form will have the same number of terms, but will use one fewer gates.</p>
</section>
</section>
<section id="question-3" class="level2">
<h2>Question 3</h2>
<section id="a-2" class="level3">
<h3>(a)</h3>
<p>Here’s the truth table for the function:</p>
<table>
<thead>
<tr class="header">
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>Y</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Here’s the Karnaugh map:</p>
<table>
<thead>
<tr class="header">
<th>AB  CD</th>
<th>00</th>
<th>01</th>
<th>11</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>00</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td><strong>01</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td><strong>11</strong></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td><strong>10</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>The SSOP can be formed by making the following groupings (as it’s the sum of products, we are aiming to cover the 1s):</p>
<ol type="1">
<li>Top-right and its left neighbour (inputs 0010 and 0011)</li>
<li>First row, third column and its upper neighbour (inputs 0011 and 1011)</li>
<li>Second row, third column and its left neighbour (inputs 0111 and 0101)</li>
<li>Second row, second column, and its lower neighbour (inputs 0101 and 1101)</li>
</ol>
<p>I’ve gone with four groups of two rather than two of two and two of one, because larger groups give simpler expressions.</p>
<p>This gives the following terms:</p>
<ol type="1">
<li>A’B’C</li>
<li>B’CD</li>
<li>A’BD</li>
<li>BC’D</li>
</ol>
<p>So the SSOP is:</p>
<pre><code>A&#39;B&#39;C + B&#39;CD + A&#39;BD + BC&#39;D</code></pre>
</section>
<section id="b-2" class="level3">
<h3>(b)</h3>
<p>We now have a slightly changed Karnaugh map with don’t-care entries (marked by Ns):</p>
<table>
<thead>
<tr class="header">
<th>AB  CD</th>
<th>00</th>
<th>01</th>
<th>11</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>00</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td><strong>01</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td><strong>11</strong></td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr class="even">
<td><strong>10</strong></td>
<td>0</td>
<td>0</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
<p>We’re still covering 1s, but now we can cover don’t-care entries as well. This gives us:</p>
<ol type="1">
<li>Top-right and its left neighbour, and their upper neighbours (inputs 0010, 0011, 1010 and 1011)</li>
<li>Second row, third column and its left neighbour, and their lower neighbours (inputs 0111, 0101, 1111 and 1101)</li>
</ol>
<p>This gives these terms:</p>
<ol type="1">
<li>B’C</li>
<li>BD</li>
</ol>
<p>So the SSOP is now:</p>
<pre><code>B&#39;C + BD</code></pre>
</section>
<section id="c-2" class="level3">
<h3>(c)</h3>
<p>Convert all ANDs to ORs with DeMorgan’s:</p>
<ul>
<li><code>B'C -&gt; (B + C')'</code></li>
<li><code>BD -&gt; (B' + D')'</code></li>
</ul>
<p>This gives:</p>
<pre><code>(B + C&#39;)&#39; + (B&#39; + D&#39;)&#39;</code></pre>
<p>To draw the circuit diagram:</p>
<ul>
<li>use a NOR for each NOR operation</li>
<li>connect an input into both inputs of a NOR for each NOT operation</li>
<li>use a NOR followed by a NOT for the OR operations</li>
</ul>
<p>My diagram has 7 NORs.</p>
</section>
<section id="d" class="level3">
<h3>(d)</h3>
<p>Convert all ORs to ANDs with DeMorgan’s:</p>
<ul>
<li><code>B'C + BD -&gt; ((B'C)' . (BD)')'</code></li>
</ul>
<p>So the answer is:</p>
<pre><code>((B&#39;C)&#39; . (BD)&#39;)&#39;</code></pre>
<p>To draw the circuit diagram:</p>
<ul>
<li>use a NAND for each NAND operation</li>
<li>connect an input into both inputs of a NAND for each NOT operation</li>
<li>use a NAND followed by a NOT for the AND operations</li>
</ul>
<p>My diagram has 4 NANDS.</p>
</section>
<section id="e" class="level3">
<h3>(e)</h3>
<table>
<thead>
<tr class="header">
<th>AB  CD</th>
<th>00</th>
<th>01</th>
<th>11</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>00</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td><strong>01</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td><strong>11</strong></td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr class="even">
<td><strong>10</strong></td>
<td>0</td>
<td>0</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
<p>To cover the 0s we can make the following groups:</p>
<ol type="1">
<li>Top-left and its right neighbour, and their upper neighbours (inputs 0000, 0001, 1001, and 1000)</li>
<li>Second row, first column and its left neighbour, and their lower neighbours (inputs 0100, 0110, 1100, and 1110)</li>
</ol>
<p>This gives these terms (remember primes are the other way around for products of sums – I forgot):</p>
<ol type="1">
<li>C + B</li>
<li>D + B’</li>
</ol>
<p>Which gives a SPOS of:</p>
<pre><code>(C + B) . (D + B&#39;)</code></pre>
</section>
</section>
<section id="question-4" class="level2">
<h2>Question 4</h2>
<section id="a-3" class="level3">
<h3>(a)</h3>
<table>
<thead>
<tr class="header">
<th>z</th>
<th>y</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
</tr>
<tr class="odd">
<td>2</td>
<td>1</td>
</tr>
<tr class="even">
<td>3</td>
<td>0</td>
</tr>
<tr class="odd">
<td>4</td>
<td>1</td>
</tr>
<tr class="even">
<td>5</td>
<td>0</td>
</tr>
<tr class="odd">
<td>6</td>
<td>0</td>
</tr>
<tr class="even">
<td>7</td>
<td>1</td>
</tr>
</tbody>
</table>
</section>
<section id="b-3" class="level3">
<h3>(b)</h3>
<table>
<thead>
<tr class="header">
<th>z  x</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>0</strong></td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td><strong>1</strong></td>
<td>2</td>
<td>3</td>
</tr>
<tr class="odd">
<td><strong>2</strong></td>
<td>4</td>
<td>5</td>
</tr>
<tr class="even">
<td><strong>3</strong></td>
<td>6</td>
<td>7</td>
</tr>
<tr class="odd">
<td><strong>4</strong></td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td><strong>5</strong></td>
<td>2</td>
<td>3</td>
</tr>
<tr class="odd">
<td><strong>6</strong></td>
<td>4</td>
<td>5</td>
</tr>
<tr class="even">
<td><strong>7</strong></td>
<td>6</td>
<td>7</td>
</tr>
</tbody>
</table>
</section>
<section id="c-3" class="level3">
<h3>(c)</h3>
<p>One sequence is:</p>
<ul>
<li><code>000111000111</code>…</li>
</ul>
<p>You can see that as you step to the right, the number of 1s increases or decreases by 1, producing alternating output.</p>
<p>Another sequence is:</p>
<ul>
<li><code>010101010101</code>…</li>
</ul>
<p>The first set of 3 has one 1, and then the next has 2, and the next has 1, and so on, producing alternating output.</p>
<p>I think these are the only two, but I’m not certain. I found them by thinking about which sequences will have different numbers of 1s in successive steps, and the fact that you can only change it by 1 each time.</p>
</section>
<section id="d-1" class="level3">
<h3>(d)</h3>
<p>A circuit realisation of this machine would contain 3 flip-flops, as there are 8 states (alternatively, as each of the last three steps needs to be recorded).</p>
</section>
</section>
</section>
</body>
</html>
