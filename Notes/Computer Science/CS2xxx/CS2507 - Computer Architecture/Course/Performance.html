<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Performance</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      div.line-block{white-space: pre-line;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="/Users/Noel/Developer/Projects/Github Page/Notes/note-style.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<section id="system-performance" class="level2">
<h2>System Performance</h2>
<p>One measure is the response time/execution time – how long it takes to do a task.</p>
<p>Another is the throughput – the total work done per unit time (e.g. tasks per hour). This is especially important for servers.</p>
<p>We’ll focus on the response time.</p>
<p>Adding a faster processor affects both, but adding more processors affects throughput more.</p>
<section id="relative-performance" class="level3">
<h3>Relative Performance</h3>
<p>Define this as 1 / the execution time.</p>
<p>Now we can represent “X is n times as fast as Y” more naturally.</p>
</section>
<section id="measuring-performance" class="level3">
<h3>Measuring Performance</h3>
<p>The <code>Elapsed Time</code> is the total time to complete a task:</p>
<pre><code>* Includes Processing, I/O, OS overhead, Idle time</code></pre>
<p>The <code>CPU Time</code> is the time spent processing a given job.</p>
<pre><code>* Doesn&#39;t include I/O time or time spent on other jobs in the middle.

* Made up of the user CPU time and the system CPU time.</code></pre>
<p>Different programs are affected differently by CPU and system performance.</p>
</section>
<section id="cpu-clocking" class="level3">
<h3>CPU Clocking</h3>
<ul>
<li>The operation of digital hardware is governed by a constant-rate clock – everything happens on clock steps.</li>
<li>The clock period is the duration of a clock cycle.</li>
<li>The clock frequency is the number of cycles per second, and is the inverse of the period.</li>
</ul>
<p>The CPU execution time for a program is the number of clock cycles multiplied by the time each cycle takes.</p>
<p>You can represent this as: # of cycles / clock rate.</p>
<p>Performance can be improved by:</p>
<ul>
<li><p>reducing the number of clock cycles</p></li>
<li><p>increasing the clock rate</p></li>
</ul>
<p>Hardware designers often need to trade off clock rate against cycle count.</p>
<p>The number of clock cycles can be found by multiplying the number of instructions (the instruction count) by the number of cycles per instruction (the CPI).</p>
<p>So we can redefine the CPU Time as (Instruction Count x CPI) / Clock Rate.</p>
<p>The instruction count for a program is determined by the program, the ISA, and the compiler.</p>
<p>The average CPI is determined by CPU hardware. If different instructions in a set have different CPIs, then the average CPI is affected by the balance of those instructions.</p>
</section>
<section id="performance-in-general" class="level3">
<h3>Performance in General</h3>
<p>CPU Time = (Instructions per program) x (Clock cycles per instruction) x (Seconds per clock cycle)</p>
<p>Performance depends on:</p>
<ul>
<li>Algorithm: Affects IC, possibly CPI</li>
<li>Programming language: affects IC, CPI</li>
<li>Compiler: affects IC, CPI</li>
<li>ISA: affects IC, CPI, Tc</li>
</ul>
<p>Time is the only reliable measure of performance.</p>
</section>
</section>
<section id="power-trends" class="level1">
<h1>Power Trends</h1>
<p>Clock rates increased until 2004, with the pentium 4 processor, which had a clock rate of 3600. However, this had a huge power consumption, and the heat made it behave erratically, so since 2004, clock rate has been staying roughly the same, while power consumption has been decreasing.</p>
<p>The dominant IC technology is CMOS, and the power consumption is given by this equation:</p>
<ul>
<li>Power = Capacitive load x Voltage^2 x Frequency</li>
</ul>
<p>Recently, we’ve been keeping the power low by decreasing the voltage (from 5V to 1V). It’s difficult to make ICs work below 1V, though.</p>
<p>Once we’ve hit the power wall, it makes sense to move to multiprocessors.</p>
</section>
<section id="multiprocessors" class="level1">
<h1>Multiprocessors</h1>
<ul>
<li>Multicore multiprocessors
<ul>
<li>Require more than one processor per chip</li>
</ul></li>
<li>This requires explicit parallel programming
<ul>
<li>Compare with instruction level parallelism, where the hardware executes multiple instructions at once, which is hidden from the programmer</li>
<li>Requires knowledge of the architecture</li>
<li>This is hard to do:
<ul>
<li>programming for performance</li>
<li>load balancing</li>
<li>optimising communication and synchronisation</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="benchmarks" class="level1">
<h1>Benchmarks</h1>
<p>Benchmarks are used to tell the difference between processors when you haven’t actually tried them.</p>
<section id="spec-power-benchmark" class="level2">
<h2>SPEC Power Benchmark</h2>
<p>Power consumption of servers at different workload levels.</p>
<ul>
<li><p>Calculate the performance at each 10% increment</p></li>
<li>Note that the power is not proportional to the load for servers.
<ul>
<li>We’re trying to design this at the moment though, as that would save energy and make it easier to manage energy consumption.</li>
</ul></li>
<li>Servers work well at 100%.</li>
<li><p>The best servers around the world typically work only at 50%, though.</p></li>
</ul>
<p>Some of the reason for higher power use than expected at low load is power leak from transistors, which are now very small.</p>
</section>
</section>
</body>
</html>
